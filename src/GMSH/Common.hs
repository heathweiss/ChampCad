{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE PatternSynonyms #-}
module GMSH.Common(BuilderStateData(..), BuilderMonadData(..), NonOverLappedClosedPoints(), pattern NonOverLappedClosedPoints', toNonOverlappingClosedPoints, newBuilderData,  GPointId(..), eval) where
{- |
Contains common datatypes, functions, etc. that are required by multiple modules, which otherwise would cause circular references.
-}

import qualified Data.HashMap.Strict as HM
import qualified Data.Hashable as H
import GHC.Generics (Generic)

import Control.Lens

import CornerPoints.Points(Point(..))
import qualified CornerPoints.CornerPoints as CPts
import qualified CornerPoints.Points as Pts

newtype GPointId = GPointId {_gPointId :: Int}
 deriving (Show, Eq)

{- |
Supplies the state data for the GMSH.Builder.Base.ExceptStackCornerPointsBuilder.
Know uses:
Combines the gmsh id, and the x y z point info and keeps it in state in the BuilderStateData.
Used to make sure that there are no duplicate points in gmsh, when inserting a Pts.Point.
-}
data BuilderStateData = BuilderStateData
                     { -- | Should be able to delete this, as lines will be written to file as they are created, and kept as the current value of state.
                       _linesMap::HM.HashMap Int Int,
                       -- | All gmsh points(GPointId) are kept here, keyed by the hashed x,y,z values.
                       -- | Ensures there are not duplicates, by seeing if the hashed x,y,z value already exists.
                       -- | If so, then retrieve the GPointId and use instead of creating a new gmsh point.
                       _pointsMap::HM.HashMap Int GPointId,
                       -- | Will supply id's for the gmsh lines once they are implemented.
                       _linesId :: [Int],
                       -- | Supply id's for the new GPointId's
                       _pointsIdSupply :: [GPointId]
                       
                     }

makeLenses ''BuilderStateData

-- | Initialize the empty BuilderStateData for running the Builder monad stack.
newBuilderData :: BuilderStateData
newBuilderData = BuilderStateData (HM.fromList []) (HM.fromList []) [1..] (map GPointId [1..])

{- |
The datatype that the GB.ExceptStackCornerPointsBuilder monad stack returns.
Needs to track gmsh: points, lines, planes, etc, for printing.
Uses GADT's to make it like a state machine.
-}
data BuilderMonadData t where  
  -- | Can be turned into [Pts.Point] -> NonOverLappedClosedPoints -> [GPointId] -> ...
  BuilderMonadData_CPoints :: [CPts.CornerPoints] -> BuilderMonadData [CPts.CornerPoints]
  -- | Gets turned into NonOverLappedClosedPoints -> [GPointId] -> ...
  BuilderMonadData_Points :: [Pts.Point] -> BuilderMonadData [Pts.Point]
  -- | A nonoverlapped closed [Pts.Point], which is the only input allowd to get a [GPointId]. Is the only state from which the [GPointId] can be gen'd.
  BuilderMonadData_NonOverLappedClosedPoints :: [Pts.Point] -> BuilderMonadData NonOverLappedClosedPoints
  -- | Gets generated by toGPoints from a NonOverLappedClosedPoints. Is the only state from which a [GLine] can be gen'd.
  BuilderMonadData_GPointIds :: [GPointId] ->  BuilderMonadData [GPointId]

-- | see: https://stackoverflow.com/questions/8172548/is-it-possible-to-export-constructors-for-pattern-matching-but-not-for-construc
-- | for pattern matching when type constructor is not exported.
pattern NonOverLappedClosedPoints' a <- NonOverLappedClosedPoints a
-- | A [Pts.Point] in which the points have no overlap, so to make line, will need to reuse each point(except head and last) for making 2 lines.
-- | The last Point will be the same as head.
-- | Does not have the constructor exported, as the the fx: toNonOverlappingClosedPoints is the only way to get to this state.
newtype NonOverLappedClosedPoints = NonOverLappedClosedPoints [Pts.Point]

{- |
definitions
closed:
A [a] in which the last == head.
Lines created from a closed [Point] will form a well formed surface, as the last line will end at the start of the 1st line.

nonoverlapping:
The point which is the end of a line, is reused to form the start of the next line.
If they were intstead overlapping, each point would exist twice(once as 1st point, once as second point, except the 1st and last points.
If they are not overlappoing, each point would have to be resued to start the next line, except the 1st and last points.

Given
points: A [Pts.Point] which may or may not be closed and overlapping.
Must be at least length == 3, so 3 lines can be created, and a well formed surface can be created from the 3 lines.

Task
Modify the [Pts.Point] to be closed and nonoverlapping.
Ensure lenght >= 3.

Return
A closed and nonoverlapping [Pts.Point] with length >=3

Known uses
This is the only way to create a NonOverLappedClosedPoints, as the constructor is not exported.
This creates a State in the BuilderMonadData, where a [GPoints] can be generated from a NonOverLappedClosedPoints, which is a closed nonoverlapped [Points].
The NonOverLappedClosedPoints will be turned into a nonoverlapped closed [GPoints].
-}
toNonOverlappingClosedPoints :: [Pts.Point] -> Either String NonOverLappedClosedPoints
toNonOverlappingClosedPoints [] = do
  Left "toNonOverlappingClosedPoints has [] passed in. Length must be at least 3 for a well formed surface"

toNonOverlappingClosedPoints (p:[]) = Left "toNonOverlappingClosedPoints has (p:[]) passed in. Length must be at least 3 for a well formed surface"
toNonOverlappingClosedPoints (p:p1:[]) = Left "toNonOverlappingClosedPoints has (p:p1:[]) passed in. Length must be at least 3 for a well formed surface"
toNonOverlappingClosedPoints points =
  let
    nonOverlappingClosedPoints = toNonOverlappingClosedPoints' (head points) (head points) points []
    --ensure that the resulting [] length >= 3.
    has3 :: NonOverLappedClosedPoints -> Bool
    has3 (NonOverLappedClosedPoints []) = False
    has3 (NonOverLappedClosedPoints (a:[])) = False
    has3 (NonOverLappedClosedPoints (a:b:[])) = False
    has3 (NonOverLappedClosedPoints (a:b:c:[])) = False
    has3 _ = True
    
  in
  case has3 nonOverlappingClosedPoints of
    True -> Right nonOverlappingClosedPoints
    False -> Left $ "toNonOverlappingClosedPoints: length of resulting [Point] < 3" 


{-
Given
head': The head of orignal [Point]. When the end of points is reached, it is used to see if list is closed.

prevPoint: Compared to the current point to see if they are overlapped.

origPoints: The orignal [Point] that is being checked for overlap and closure.

workingPoints: The [Point] being created that is not overlapped and is closed.

Task
Work through the orignal [Point], ensuring no overlap, and that it is closed.

Return
Closed and nonoverlapped [Point]
-}
toNonOverlappingClosedPoints' :: Pts.Point -> Pts.Point -> [Pts.Point] -> [Pts.Point] -> NonOverLappedClosedPoints
--Have hit the end of list. Ensure closed, then reverse the build up working list.
toNonOverlappingClosedPoints' head' prevPoint [] workingPoints =
  case head' == prevPoint of
    True ->  NonOverLappedClosedPoints $ reverse workingPoints --Is closed.
    False ->  NonOverLappedClosedPoints $ reverse $ head' : workingPoints --Not closed, so head' to the end of working list.
toNonOverlappingClosedPoints' head' prevPoint (p:origPoints) workingPoints =
  case p == prevPoint of
    True -> toNonOverlappingClosedPoints' head' p origPoints workingPoints
    False -> toNonOverlappingClosedPoints' head' p origPoints (p:workingPoints)

{-
toNonOverlappingClosedPoints' :: Pts.Point -> Pts.Point -> [Pts.Point] -> [Pts.Point] -> Either String [Pts.Point]
--Have hit the end of list. Ensure closed, then reverse the build up working list.
toNonOverlappingClosedPoints' head' prevPoint [] workingPoints =
  case head' == prevPoint of
    True -> Right $ reverse workingPoints --Is closed.
    False -> Right $ reverse $ head' : workingPoints --Not closed, so head' to the end of working list.
toNonOverlappingClosedPoints' head' prevPoint (p:origPoints) workingPoints =
  case p == prevPoint of
    True -> toNonOverlappingClosedPoints' head' p origPoints workingPoints
    False -> toNonOverlappingClosedPoints' head' p origPoints (p:workingPoints)
-}

-- | Extract the inner data from the BuilderMonadData
eval :: BuilderMonadData t -> t 
eval (BuilderMonadData_GPointIds gPointIds) = gPointIds
eval (BuilderMonadData_Points points) = points
eval (BuilderMonadData_CPoints cpts) = cpts
eval (BuilderMonadData_NonOverLappedClosedPoints nonOverLappedClosedPoints) = NonOverLappedClosedPoints nonOverLappedClosedPoints




--needed for testing
instance Show BuilderStateData where
  --show (BuilderData linesMap _) = show linesMap
  show builderData = show $ (builderData ^. linesMap,builderData ^. pointsMap)
  
--only needed for testing
instance Eq BuilderStateData where
  --(BuilderData linesMap _) == (BuilderData linesMap' _) = linesMap == linesMap'
  builderData == builderData' = ((builderData ^. linesMap) == (builderData' ^. linesMap))
                                &&
                                ((builderData ^. pointsMap) == (builderData' ^. pointsMap))



--catchError_h :: 

